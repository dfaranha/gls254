

# This file was *autogenerated* from the file ec.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_27 = Integer(27); _sage_const_0 = Integer(0); _sage_const_28948022309329048855892746252171976963485251808731388644510120425402211310058 = Integer(28948022309329048855892746252171976963485251808731388644510120425402211310058); _sage_const_2 = Integer(2); _sage_const_0x5E0B72A98520F5A2D203CD2E4A5AE839 = Integer(0x5E0B72A98520F5A2D203CD2E4A5AE839); _sage_const_0x71B98581F8673A759639BBC43B8D797B = Integer(0x71B98581F8673A759639BBC43B8D797B); _sage_const_0x3ADACC9B694B43DB1D0CB95BEE9D4C31 = Integer(0x3ADACC9B694B43DB1D0CB95BEE9D4C31); _sage_const_0x3C8194E0263521C800C63FF2D65C6505 = Integer(0x3C8194E0263521C800C63FF2D65C6505); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_11 = Integer(11); _sage_const_8 = Integer(8); _sage_const_10 = Integer(10); _sage_const_6 = Integer(6); _sage_const_17 = Integer(17); _sage_const_127 = Integer(127); _sage_const_0x2BACF997126F185C3E67CB944EEB1168 = Integer(0x2BACF997126F185C3E67CB944EEB1168); _sage_const_14474011154664524427946373126085988481488994894707048965286167243381422079089 = Integer(14474011154664524427946373126085988481488994894707048965286167243381422079089); _sage_const_5 = Integer(5); _sage_const_13 = Integer(13); _sage_const_85070591730234615877113501116496779623 = Integer(85070591730234615877113501116496779623); _sage_const_44 = Integer(44); _sage_const_7 = Integer(7)
from random import randrange


load("cp.sage")
load("field.sage")

# Define curve coefficients, notice we are using a different b than the original paper.
one = F2m(_sage_const_1 )
a = F2x(s);
b = F2m(z**_sage_const_27  + one)

E = EllipticCurve(F2x, [_sage_const_1 , s, _sage_const_0 , _sage_const_0 , b])
# Sage does not compute the order of this curve, so I brought it over from MAGMA. It is 2 * r, for prime r.
n = _sage_const_28948022309329048855892746252171976963485251808731388644510120425402211310058 ;
# Cofactor of the prime-order subgroup
h = _sage_const_2 
r = n//h

def generator(E):
    # Let's get a generator of the right order from MAGMA.
    x0 = F2m.fetch_int(_sage_const_0x5E0B72A98520F5A2D203CD2E4A5AE839 )
    x1 = F2m.fetch_int(_sage_const_0x71B98581F8673A759639BBC43B8D797B )
    y0 = F2m.fetch_int(_sage_const_0x3ADACC9B694B43DB1D0CB95BEE9D4C31 )
    y1 = F2m.fetch_int(_sage_const_0x3C8194E0263521C800C63FF2D65C6505 )
    xP = x1*s + x0
    yP = y1*s + y0
    return E(xP,yP)

def to_lambda_aff(P):
    xP = P[_sage_const_0 ]
    lP = P[_sage_const_0 ] + P[_sage_const_1 ]/P[_sage_const_0 ]
    assert((lP**_sage_const_2  + lP + a)*xP**_sage_const_2  == xP**_sage_const_4  + b)
    return (xP, lP)

def to_lambda_prj(P):
    xP, lP = to_lambda_aff(P)
    return (xP, lP, one)

def from_lambda_aff(xP, lP):
    return E(xP, (lP + xP) * xP)

def from_lambda_prj(Xp, Lp, Zp):
    return E(Xp/Zp, (Lp/Zp + Xp/Zp) * Xp/Zp)

def double_weiss(xP, lP):
    # Now compute the formulas and verify, it should be true at the end.
    x2P = lP**_sage_const_2  + lP + a
    y2P = xP**_sage_const_2  + lP*x2P + x2P
    return (x2P, y2P)

def double_aff(xP, lP):
    x2P = lP**_sage_const_2  + lP + a
    l2P = xP**_sage_const_2  / x2P + lP**_sage_const_2  + a + _sage_const_1 
    return (x2P, l2P)

def double_prj(Xp, Lp, Zp):
    global mt, ma, mb, sq
    mt += _sage_const_4 
    ma += _sage_const_1 
    sq += _sage_const_4 
    T = Lp**_sage_const_2  + Lp * Zp + a * Zp**_sage_const_2 
    X2 = T**_sage_const_2 
    Z2 = T * Zp**_sage_const_2 
    L2 = (Xp * Zp)**_sage_const_2  + X2 + T * (Lp * Zp) + Z2
    return (X2, L2, Z2)

def doubleb_prj(Xp, Lp, Zp):
    global mt, ma, mb, sq
    mt += _sage_const_3 
    ma += _sage_const_1 
    mb += _sage_const_1 
    sq += _sage_const_4 
    T = Lp**_sage_const_2  + Lp * Zp + a * Zp**_sage_const_2 
    X2 = T**_sage_const_2 
    Z2 = T * Zp**_sage_const_2 
    L2 = (Lp + Xp)**_sage_const_2  * ((Lp + Xp)**_sage_const_2  + T + Zp**_sage_const_2 ) + (a**_sage_const_2  + b) * Zp**_sage_const_4  + X2 + (a + _sage_const_1 ) * Z2
    return (X2, L2, Z2)

def add_prj(Xp, Lp, Zp, Xq, Lq, Zq):
    global mt, ma, mb, sq
    mt += _sage_const_11 
    sq += _sage_const_2 
    A = Lp * Zq + Lq * Zp
    B = (Xp * Zq + Xq * Zp)**_sage_const_2 
    Xpq = A * (Xp * Zq) * (Xq * Zp) * A
    Lpq = (A * (Xq * Zp) + B)**_sage_const_2  + (A * B * Zq) * (Lp + Zp)
    Zpq = (A * B * Zq) * Zp
    return (Xpq, Lpq, Zpq)

def add_mix(Xp, Lp, Zp, xQ, lQ):
    global mt, ma, mb, sq
    mt += _sage_const_8 
    sq += _sage_const_2 
    A = Lp + lQ * Zp
    B = (Xp + xQ * Zp)**_sage_const_2 
    Xpq = A * Xp * (xQ * Zp) * A
    Lpq = (A * (xQ * Zp) + B)**_sage_const_2  + (A * B) * (Lp + Zp)
    Zpq = (A * B) * Zp
    return (Xpq, Lpq, Zpq)

def double_add(Xq, Lq, Zq, xP, lP):
    global mt, ma, mb, sq
    mt += _sage_const_10 
    ma += _sage_const_1 
    sq += _sage_const_6 

    T = Lq**_sage_const_2  + Lq * Zq + a * Zq**_sage_const_2 
    A = Xq**_sage_const_2  *Zq**_sage_const_2  + T*(Lq**_sage_const_2  + (a+_sage_const_1 +lP)*Zq**_sage_const_2 )
    B = (xP * Zq**_sage_const_2  + T)**_sage_const_2 
    Xr = (xP * Zq**_sage_const_2 ) * A**_sage_const_2 
    Zr = A * B *Zq**_sage_const_2 
    Lr = T*(A+B)**_sage_const_2  + (lP+_sage_const_1 )*Zr
    return (Xr, Lr, Zr)

def double_add_add(Xq, Lq, Zq, xP1, lP1, xP2, lP2):
    global mt, ma, mb, sq
    mt += _sage_const_17 
    ma += _sage_const_1 
    sq += _sage_const_8 

    T = Lq**_sage_const_2  + Lq*Zq + a*Zq**_sage_const_2 
    U = Xq**_sage_const_2  * Zq**_sage_const_2  + T*(Lq**_sage_const_2  + (a + _sage_const_1  + lP1)*Zq**_sage_const_2 )
    F = xP1 * Zq**_sage_const_2 
    G = (F+T)**_sage_const_2 
    H = U**_sage_const_2  * F
    I = U * G * Zq**_sage_const_2 
    J = (lP1 + lP2 + _sage_const_1 )*I + T*(U+G)**_sage_const_2 

    (Xc, Lc, Zc) = double_add(Xq, Lq, Zq, xP1, lP1)
    assert H == Xc
    assert I == Zc
    assert J == lP2 * Zc + Lc
    K = xP2 * I
    L = (H + K)**_sage_const_2 
    M = H * J
    Xr = J * K * M
    Zr = I * J * L
    Lr = (L + M)**_sage_const_2  + Zr*(lP2 + _sage_const_1 )
    return (Xr, Lr, Zr)

def neg_aff(xP, lP):
    return (xP, lP + _sage_const_1 )

def neg_proj(Xp, Lp, Zp):
    return (Xp, Lp + Zp, Zp)

def psi_aff(xP, lP):
    return (xP[_sage_const_0 ] + xP[_sage_const_1 ] + xP[_sage_const_1 ]*s, lP[_sage_const_0 ] + lP[_sage_const_1 ] + (lP[_sage_const_1 ] + _sage_const_1 )*s)

def curve_details(b):
    #Define a curve that E is a quadratic twist of
    q = ZZ(_sage_const_2 **_sage_const_127 )
    E = EllipticCurve(F2m, [_sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_0 , b])
    t = q + _sage_const_1  - E.cardinality()
    #t=-t also gives solution
    n = (q-_sage_const_1 )**_sage_const_2  + t**_sage_const_2 

    r = n // _sage_const_2  #r = max(n.factor())[0]
    S = Integers(r)
    #Formula from "A New Double Point Multiplication Method..."
    mu = S(q-_sage_const_1 )*(S(t)**(-_sage_const_1 ))
    return n, r, t, mu

def curve_details_test():
    print("Based on current curve")
    n1, r1, t, mu = curve_details(b)

    assert n == n1
    assert r == r1
    assert mu**_sage_const_2  + _sage_const_1  == _sage_const_0 

    print("Based on values in paper A New Double Point Multiplication Method")
    b1 = F2m.fetch_int(_sage_const_0x2BACF997126F185C3E67CB944EEB1168 )
    n1, r1, t, mu = curve_details(b1)
    S = Integers(r1)
    assert n1 == _sage_const_2 *r1
    assert r1 == ZZ(_sage_const_14474011154664524427946373126085988481488994894707048965286167243381422079089 )
    assert mu**_sage_const_2  + _sage_const_1  == _sage_const_0 
    #assert S(mu) == S(8008021148421066531327005693257209127155969932631024546964258714431222018403)
    print("Curve details works!")

#As described by Karabina et al
def decomp(k, t):
    q = ZZ(_sage_const_2 **_sage_const_127 )
    beta1 = (QQ(_sage_const_1 -q)/QQ(t**_sage_const_2  + (q-_sage_const_1 )**_sage_const_2 ))*QQ(k)
    beta2 = (QQ(t)/QQ(t**_sage_const_2  + (q-_sage_const_1 )**_sage_const_2 ))*QQ(k)
    b1 = beta1.round()
    b2 = beta2.round()

    k1 = k - b1*(_sage_const_1 -q) - b2*t
    k2 = - b1*t - b2*(q-_sage_const_1 )
    return k1, k2

def decomp_test():
    n, r, t, mu = curve_details(b)
    k = ZZ(r-_sage_const_2 )
    k1, k2 = decomp(k, t)
    print(k1, k2)
    S = Integers(r)
    assert S(k1)+S(k2)*S(mu) == S(k)
    print("Decomp works!")

def smu_double_add(xP, lP, scalar):
    (Xq, Lq, Zq) = (xP, lP, one)
    bits = list(reversed(Integer(scalar).bits()))
    for i in bits[_sage_const_1 :]:
        (Xq, Lq, Zq) = doubleb_prj(Xq, Lq, Zq)
        if i:
            (Xq, Lq, Zq) = add_mix(Xq, Lq, Zq, xP, lP)
    return (Xq, Lq, Zq)

def smu_double_always_add(xP, lP, scalar):
    (Xq, Lq, Zq) = (xP, lP, one)
    bits = list(reversed(Integer(scalar).bits()))
    for i in bits[_sage_const_1 :]:
        (Xq, Lq, Zq) = doubleb_prj(Xq, Lq, Zq)
        (X3, L3, Z3) = add_mix(Xq, Lq, Zq, xP, lP)
        if i: (Xq, Lq, Zq) = (X3, L3, Z3)
    return (Xq, Lq, Zq)

def smu_double_add_glv(xP, lP, scalar):
    n, r, t, mu = curve_details(b)
    k1, k2 = decomp(scalar, t)
    assert((k1 + k2*mu) % r == scalar)

    _xP, _lP = psi_aff(xP, lP)
    if (k1 < _sage_const_0 ): lP += _sage_const_1 
    if (k2 < _sage_const_0 ): _lP += _sage_const_1 

    bits1 = list(Integer(k1).bits())
    bits2 = list(Integer(k2).bits())

    l = max(len(bits1), len(bits2))
    if (len(bits1) > len(bits2)):
        (Xq, Lq, Zq) = (xP, lP, one)
    if (len(bits2) > len(bits1)):
        (Xq, Lq, Zq) = (_xP, _lP, one)
    if (len(bits1) == len(bits2)):
        (Xq, Lq, Zq) = add_mix(xP, lP, one, _xP, _lP)

    for i in range(l - _sage_const_2 , -_sage_const_1 , -_sage_const_1 ):
        (Xq, Lq, Zq) = doubleb_prj(Xq, Lq, Zq)
        if (i < len(bits1) and bits1[i] != _sage_const_0 ):
            (Xq, Lq, Zq) = add_mix(Xq, Lq, Zq, xP, lP)
        if (i < len(bits2) and bits2[i] != _sage_const_0 ):
            (Xq, Lq, Zq) = add_mix(Xq, Lq, Zq, _xP, _lP)
    return (Xq, Lq, Zq)

def smu_double_add_glv_reg(xP, lP, scalar, w = _sage_const_4 ):
    #b = F2m(z^49 + z^25 + 1)
    n, r, t, mu = curve_details(b)
    k1, k2 = decomp(scalar, t)
    assert((k1+k2*mu) % r == scalar)

    c1 = (k1 + _sage_const_1 ) % _sage_const_2 
    c2 = (k2 + _sage_const_1 ) % _sage_const_2 
    k1 = k1 + c1
    k2 = k2 + c2
    k1r = regular_recode(k1, w)
    k2r = regular_recode(k2, w)
    l = len(k1r)

    T = []
    (x2, l2) = double_aff(xP, lP)
    (Xacc, Lacc, Zacc) = (xP, lP, one)
    for i in range(_sage_const_2 **(w-_sage_const_2 )):
        T.append((Xacc / Zacc, Lacc / Zacc))
        (Xacc, Lacc, Zacc) = add_mix(Xacc, Lacc, Zacc, x2, l2)

    #Will convert table to affine coordinates using simultaneous inversion algorithm, so add costs here:
    global mt, ma, mb, sq
    mt += _sage_const_5 *(_sage_const_2 **(w-_sage_const_2 )-_sage_const_1 ) + _sage_const_13 

    _xP, _lP = psi_aff(xP, lP)
    (xP1, lP1, xP2, lP2) = (one, one, one, one)

    (xP1, lP1) = T[(abs(k1r[l-_sage_const_1 ])-_sage_const_1 )/_sage_const_2 ]
    (xP2, lP2) = T[(abs(k2r[l-_sage_const_1 ])-_sage_const_1 )/_sage_const_2 ]
    (xP2, lP2) = psi_aff(xP2, lP2)
    if k1r[l-_sage_const_1 ] < _sage_const_0 :
        (xP1, lP1) = neg_aff(xP1, lP1)
    if k2r[l-_sage_const_1 ] < _sage_const_0 :
        (xP2, lP2) = neg_aff(xP2, lP2)
    (Xq, Lq, Zq) = add_mix(xP1, lP1, one, xP2, lP2)

    for i in range(l - _sage_const_2 , -_sage_const_1 , -_sage_const_1 ):
        for j in range(w-_sage_const_2 ):
            (Xq, Lq, Zq) = doubleb_prj(Xq, Lq, Zq)
        (xP1, lP1) = T[(abs(k1r[i])-_sage_const_1 )/_sage_const_2 ]
        (xP2, lP2) = T[(abs(k2r[i])-_sage_const_1 )/_sage_const_2 ]
        (xP2, lP2) = psi_aff(xP2, lP2)

        if k1r[i] < _sage_const_0 :
            (xP1, lP1) = neg_aff(xP1, lP1)
        if k2r[i] < _sage_const_0 :
            (xP2, lP2) = neg_aff(xP2, lP2)
        (Xq, Lq, Zq) = double_add_add(Xq, Lq, Zq, xP1, lP1, xP2, lP2)

    if c1 == _sage_const_1 :
        (mxP, mlP) = neg_aff(xP, lP)
        (Xq, Lq, Zq) = add_mix(Xq, Lq, Zq, mxP, mlP)
    if c2 == _sage_const_1 :
        (mxP, mlP) = neg_aff(_xP, _lP)
        (Xq, Lq, Zq) = add_mix(Xq, Lq, Zq, mxP, mlP)

    return (Xq, Lq, Zq)

def smu_double_add_glv_reg_tab(xP, lP, scalar, w = _sage_const_4 ):
    #b = F2m(z^49 + z^25 + 1)
    n, r, t, mu = curve_details(b)
    k1, k2 = decomp(scalar, t)
    assert((k1+k2*mu) % r == scalar)

    c1 = (k1 + _sage_const_1 ) % _sage_const_2 
    c2 = (k2 + _sage_const_1 ) % _sage_const_2 
    k1 = k1 + c1
    k2 = k2 + c2
    k1r = regular_recode(k1, w)
    k2r = regular_recode(k2, w)
    l = len(k1r)

    T1 = []
    T2 = []
    T  = []
    (x2, l2) = double_aff(xP, lP)
    (Xacc, Lacc, Zacc) = (xP, lP, one)
    for i in range(_sage_const_2 **(w-_sage_const_2 )):
        T1.append((Xacc / Zacc, Lacc / Zacc))
        T2.append(psi_aff(Xacc / Zacc, Lacc / Zacc))
        (Xacc, Lacc, Zacc) = add_mix(Xacc, Lacc, Zacc, x2, l2)

    #Will convert table to affine coordinates using simultaneous inversion algorithm, so add costs here:
    global mt, ma, mb, sq
    mt += _sage_const_5 *(_sage_const_2 **(w-_sage_const_2 )-_sage_const_1 ) + _sage_const_13 

    for i in range(_sage_const_2 **(w-_sage_const_2 )):
        (xP1, lP1) = T1[i]
        for j in range(_sage_const_2 **(w-_sage_const_2 )):
            (xP2, lP2) = T2[j]
            (Xacc, Lacc, Zacc) = add_mix(xP1, lP1, one, xP2, lP2)
            T.append((Xacc / Zacc, Lacc / Zacc))

    #Will convert table to affine coordinates using simultaneous inversion algorithm, so add costs here:
    mt += _sage_const_5 *(_sage_const_2 **(_sage_const_2 *(w-_sage_const_2 ))-_sage_const_1 ) + _sage_const_13 

    _xP, _lP = psi_aff(xP, lP)
    (xP1, lP1, xP2, lP2) = (one, one, one, one)

    (xP1, lP1) = T1[(abs(k1r[l-_sage_const_1 ])-_sage_const_1 )/_sage_const_2 ]
    (xP2, lP2) = T2[(abs(k2r[l-_sage_const_1 ])-_sage_const_1 )/_sage_const_2 ]
    if k1r[l-_sage_const_1 ] < _sage_const_0 :
        (xP1, lP1) = neg_aff(xP1, lP1)
    if k2r[l-_sage_const_1 ] < _sage_const_0 :
        (xP2, lP2) = neg_aff(xP2, lP2)
    (Xq, Lq, Zq) = add_mix(xP1, lP1, one, xP2, lP2)

    for i in range(l - _sage_const_2 , -_sage_const_1 , -_sage_const_1 ):
        for j in range(w-_sage_const_2 ):
            (Xq, Lq, Zq) = doubleb_prj(Xq, Lq, Zq)

        if k1r[i] > _sage_const_0  and k2r[i] > _sage_const_0 :
            k = _sage_const_2 **(w-_sage_const_2 )*(abs(k1r[i])-_sage_const_1 )/_sage_const_2  + (abs(k2r[i])-_sage_const_1 )/_sage_const_2 
            (xP1, lP1) = T[k]
        if k1r[i] < _sage_const_0  and k2r[i] < _sage_const_0 :
            k = _sage_const_2 **(w-_sage_const_2 )*(abs(k1r[i])-_sage_const_1 )/_sage_const_2  + (abs(k2r[i])-_sage_const_1 )/_sage_const_2 
            (xP1, lP1) = T[k]
            (xP1, lP1) = neg_aff(xP1, lP1)
        if k1r[i] < _sage_const_0  and k2r[i] > _sage_const_0 :
            k = _sage_const_2 **(w-_sage_const_2 )*(abs(k2r[i])-_sage_const_1 )/_sage_const_2  + (abs(k1r[i])-_sage_const_1 )/_sage_const_2 
            (xP1, lP1) = T[k]
            (xP1, lP1) = psi_aff(xP1, lP1)
        if k1r[i] > _sage_const_0  and k2r[i] < _sage_const_0 :
            k = _sage_const_2 **(w-_sage_const_2 )*(abs(k2r[i])-_sage_const_1 )/_sage_const_2  + (abs(k1r[i])-_sage_const_1 )/_sage_const_2 
            (xP1, lP1) = T[k]
            (xP1, lP1) = psi_aff(xP1, lP1)
            (xP1, lP1) = neg_aff(xP1, lP1)
        (Xq, Lq, Zq) = double_add(Xq, Lq, Zq, xP1, lP1)

    if c1 == _sage_const_1 :
        (mxP, mlP) = neg_aff(xP, lP)
        (Xq, Lq, Zq) = add_mix(Xq, Lq, Zq, mxP, mlP)
    if c2 == _sage_const_1 :
        (mxP, mlP) = neg_aff(_xP, _lP)
        (Xq, Lq, Zq) = add_mix(Xq, Lq, Zq, mxP, mlP)

    return (Xq, Lq, Zq)

#Input must be odd
#Modified alg 6 from "Exponent Recoding and Regular Exponentiation Algorithms"
#by Joye et al
def regular_recode(k, w):
    l = ZZ(QQ(_sage_const_127 /(w-_sage_const_1 )).ceil()+_sage_const_1 )
    v = ZZ(_sage_const_2 **(w-_sage_const_1 ))
    acc = k
    k_reg = [_sage_const_0 ] * l

    for i in range(l-_sage_const_1 ):
        k_reg[i] = (acc % (_sage_const_2 *v))-v
        acc = ZZ((acc-k_reg[i])/v)

    k_reg[l-_sage_const_1 ] = acc
    return k_reg

def regular_recode_test():
    k1 = ZZ(_sage_const_85070591730234615877113501116496779623 )
    w = _sage_const_4 
    k1_reg = regular_recode(k1, w)
    assert(len(k1_reg) == _sage_const_44 )

    acc = ZZ(_sage_const_0 )
    v = ZZ(_sage_const_1 )
    for i in range(len(k1_reg)):
        acc = acc + k1_reg[i]*v
        v = v * _sage_const_2 **(w-_sage_const_1 )
    assert acc == k1
    print("Regular recoding works!")

# We can see that the curve has a point (p, sqrt(b)) of small of small order 2
P = E(_sage_const_0 , sqrt(b))
assert(_sage_const_2 *P == _sage_const_0 *P)

# If this is a valid point in the curve, the following should be the point at infinity.
P = h * generator(E)
assert(r*P == _sage_const_0 *P)
Q = randrange(r) * P
R = randrange(r) * P

curve_details_test()
decomp_test()
regular_recode_test()

mt = ma = mb = sq = _sage_const_0 
_, _, _, mu = curve_details(b)

print("looking for exception")
for i in range(_sage_const_1 , _sage_const_1 , _sage_const_1 ):
    print(i)
    P = randrange(r)*P
    (xP, lP) = to_lambda_aff(P)
    k = r - _sage_const_1 
    (X3, L3, Z3) = smu_double_add_glv_reg(xP, lP, k)
    valid = from_lambda_prj(X3, L3, Z3) == k*P
    if not valid:
        print(P)
    assert valid
print("done")

for i in range(_sage_const_0 , _sage_const_10 ):
    k = randrange(r)

    # Pick a random point
    P = k * P
    Q = k * Q
    R = k * R

    (xP, lP) = to_lambda_aff(P)
    (xQ, lQ) = to_lambda_aff(Q)
    (xR, lR) = to_lambda_aff(R)

    # Test convertion to/from lambda coordinates
    assert(P == from_lambda_aff(xP, lP))
    assert(from_lambda_prj(xP, lP, one) == P)

    # Test point compression method
    cp = compress(xP, lP)
    assert((xP, lP) == uncompress(cp))

    # Test point doubling formulas
    assert(E(double_weiss(xP, lP)) == _sage_const_2 *P)

    (xP, lP) = double_aff(xP, lP)
    assert(from_lambda_aff(xP, lP) == _sage_const_2 *P)

    P = _sage_const_2  * P
    (X2, L2, Z2) = double_prj(xP, lP, one)
    assert(from_lambda_prj(X2, L2, Z2) == _sage_const_2 *P)
    (X2, L2, Z2) = doubleb_prj(xP, lP, one)
    assert(from_lambda_prj(X2, L2, Z2) == _sage_const_2 *P)

    # Test point addition formulas
    (X3, L3, Z3) = add_mix(xP, lP, one, xQ, lQ)
    assert(from_lambda_prj(X3, L3, Z3) == P + Q)
    (X3, L3, Z3) = add_prj(xP, lP, one, xQ, lQ, one)
    assert(from_lambda_prj(X3, L3, Z3) == P + Q)

    #Test atomic formulas:
    (X3, L3, Z3) = double_add(xQ, lQ, one, xP, lP)
    assert(from_lambda_prj(X3, L3, Z3) == _sage_const_2 *Q + P)
    (X3, L3, Z3) = double_add_add(xQ, lQ, one, xP, lP, xR, lR)
    assert(from_lambda_prj(X3, L3, Z3) == _sage_const_2 *Q + P + R)

    # Test scalar multiplication algorithms
    (X3, L3, Z3) = smu_double_add(xP, lP, k)
    assert(from_lambda_prj(X3, L3, Z3) == k*P)
    (X3, L3, Z3) = smu_double_always_add(xP, lP, k)
    assert(from_lambda_prj(X3, L3, Z3) == k*P)
    (X3, L3, Z3) = smu_double_add_glv(xP, lP, k)
    assert(from_lambda_prj(X3, L3, Z3) == k*P)
    (X3, L3, Z3) = smu_double_add_glv_reg(xP, lP, k, _sage_const_4 )
    assert(from_lambda_prj(X3, L3, Z3) == k*P)
    (X3, L3, Z3) = smu_double_add_glv_reg(xP, lP, k, _sage_const_5 )
    assert(from_lambda_prj(X3, L3, Z3) == k*P)
    (X3, L3, Z3) = smu_double_add_glv_reg(xP, lP, k, _sage_const_6 )
    assert(from_lambda_prj(X3, L3, Z3) == k*P)
    (X3, L3, Z3) = smu_double_add_glv_reg(xP, lP, k, _sage_const_7 )
    assert(from_lambda_prj(X3, L3, Z3) == k*P)
    (X3, L3, Z3) = smu_double_add_glv_reg_tab(xP, lP, k, _sage_const_4 )
    assert(from_lambda_prj(X3, L3, Z3) == k*P)
    (X3, L3, Z3) = smu_double_add_glv_reg_tab(xP, lP, k, _sage_const_5 )
    assert(from_lambda_prj(X3, L3, Z3) == k*P)
    (X3, L3, Z3) = smu_double_add_glv_reg_tab(xP, lP, k, _sage_const_6 )
    assert(from_lambda_prj(X3, L3, Z3) == k*P)

    (xP, lP) = psi_aff(xP, lP)
    assert(from_lambda_aff(xP, lP) == int(mu)*P)

# Benchmarks by operation counts
print("Operation counts as (muls, mul_a, mul_b, sqrs)")

mt = ma = mb = sq = _sage_const_0 
(X3, L3, Z3) = smu_double_add(xP, lP, k)
print("Double-add       : ", mt, ma, mb, sq)

mt = ma = mb = sq = _sage_const_0 
(X3, L3, Z3) = smu_double_always_add(xP, lP, k)
print("Double-add-always: ", mt, ma, mb, sq)

mt = ma = mb = sq = _sage_const_0 
(X3, L3, Z3) = smu_double_add_glv(xP, lP, k)
print("GLV-double-add: ", mt, ma, mb, sq)

mt = ma = mb = sq = _sage_const_0 
(X3, L3, Z3) = smu_double_add_glv_reg(xP, lP, k, _sage_const_4 )
print("GLV-reg-4-double-add: ", mt, ma, mb, sq)

mt = ma = mb = sq = _sage_const_0 
(X3, L3, Z3) = smu_double_add_glv_reg(xP, lP, k, _sage_const_5 )
print("GLV-reg-5-double-add: ", mt, ma, mb, sq)

mt = ma = mb = sq = _sage_const_0 
(X3, L3, Z3) = smu_double_add_glv_reg(xP, lP, k, _sage_const_6 )
print("GLV-reg-6-double-add: ", mt, ma, mb, sq)

mt = ma = mb = sq = _sage_const_0 
(X3, L3, Z3) = smu_double_add_glv_reg_tab(xP, lP, k, _sage_const_4 )
print("GLV-reg-4-double-add-tab: ", mt, ma, mb, sq)

mt = ma = mb = sq = _sage_const_0 
(X3, L3, Z3) = smu_double_add_glv_reg_tab(xP, lP, k, _sage_const_5 )
print("GLV-reg-5-double-add-tab: ", mt, ma, mb, sq)

mt = ma = mb = sq = _sage_const_0 
(X3, L3, Z3) = smu_double_add_glv_reg_tab(xP, lP, k, _sage_const_6 )
print("GLV-reg-6-double-add-tab: ", mt, ma, mb, sq)

